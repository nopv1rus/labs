#include "stdafx.h"
#include "HashScan.h"
#include <WinCrypt.h>
#include <Tlhelp32.h>

#pragma comment(lib, "Advapi32.lib")

MND_HASH_MD5 g_stMD5Pattern[] = {
#include "hashmd5.inc"
};

HashEngine::HashEngine()
{
	m_PatternSize = sizeof(g_stMD5Pattern)/sizeof(MND_HASH_MD5);
	if(m_PatternSize <= 0)
		m_EnableEng = FALSE;
	else
		m_EnableEng = TRUE;
}

HashEngine::~HashEngine()
{
}

BOOL HashEngine::GetFileInfo(WCHAR *pwszFile, IN PST_SCAN_INFO pDestObject)
{
	BOOL	bRet = FALSE;

	DWORD	dwLen = 0;
	DWORD	dwFilestate = 0;

	if (pwszFile == NULL || pDestObject == NULL)
	{
		return FALSE;
	}

	//파일 존재 확인 및 접근 확인
	dwFilestate = GetFileAttributesW(pwszFile);
	if (dwFilestate == INVALID_FILE_ATTRIBUTES)
	{
		goto END;
	}

	dwLen = WideCharToMultiByte(CP_ACP,0,pwszFile, -1 , NULL, NULL, NULL, NULL);
	if (dwLen == 0)
	{
		goto END;
	}

	pDestObject->stFileInfo.pwszFileFullPath = (WCHAR *) malloc( (dwLen * sizeof(WCHAR)) + 0x10);
	if (pDestObject->stFileInfo.pwszFileFullPath == NULL)
	{
		goto END;
	}

	ZeroMemory(pDestObject->stFileInfo.pwszFileFullPath, (dwLen * sizeof(WCHAR)) + 0x10);

	_snwprintf(pDestObject->stFileInfo.pwszFileFullPath, dwLen, _T("%s"), pwszFile);

	bRet = TRUE;

END:
	return bRet;
}

BOOL HashEngine::Openfile(PST_SCAN_INFO pDestObject, DWORD dwOpenmode)
{
	BOOL		bRet = FALSE;

	DWORD		dwOpenOpt = 0;
	DWORD		dwMappingOpt = 0;
	DWORD		dwViewOpt = 0;
	DWORD		dwFilestate = 0;
	DWORD		dwLen = 0;

	if (pDestObject == NULL || dwOpenmode == 0)
	{
		return bRet;
	}

	//진단하는 경우에는 READ 권한으로만 파일을 열며, 치료하는 경우에는 READ+WRITE로 접근
	if (dwOpenmode == ONLYREAD )
	{
		dwOpenOpt = GENERIC_READ;
	}
	else
	{
		dwOpenOpt = GENERIC_READ|GENERIC_WRITE;
	}


	pDestObject->stFileInfo.hFile = CreateFileW(pDestObject->stFileInfo.pwszFileFullPath, dwOpenOpt, FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (pDestObject->stFileInfo.hFile == INVALID_HANDLE_VALUE)
	{
		goto END;
	}

	pDestObject->stFileInfo.dwFSize = GetFileSize(pDestObject->stFileInfo.hFile, NULL);
	if (pDestObject->stFileInfo.dwFSize == INVALID_FILE_SIZE)
	{
		goto END;
	}


	bRet = TRUE;


END:

	if (bRet == FALSE)
	{
		this->Closefile(pDestObject);
	}

	return bRet;
}


VOID HashEngine::ResetInfo (IN PST_SCAN_INFO pDestObject)
{
	BOOL		bRet = FALSE;

	DWORD		dwOpenOpt = 0;
	DWORD		dwFilestate = 0;
	DWORD		dwLen = 0;

	if (pDestObject != NULL)
	{
		if (pDestObject->stFileInfo.pwszFileFullPath != NULL)
		{
			free(pDestObject->stFileInfo.pwszFileFullPath);
			pDestObject->stFileInfo.pwszFileFullPath = NULL;
		}

	}
}

VOID HashEngine::Closefile (IN PST_SCAN_INFO pDestObject)
{
	BOOL		bRet = FALSE;

	DWORD		dwOpenOpt = 0;
	DWORD		dwFilestate = 0;
	DWORD		dwLen = 0;

	ResetInfo(pDestObject);

	if (pDestObject != NULL)
	{
		pDestObject->stFileInfo.dwFSize = 0;

		if ( pDestObject->stFileInfo.pbyFileBuff != NULL)
		{
			UnmapViewOfFile(pDestObject->stFileInfo.pbyFileBuff);
			pDestObject->stFileInfo.pbyFileBuff = NULL;
		}

		if ( pDestObject->stFileInfo.hFileMapping != NULL)
		{
			CloseHandle(pDestObject->stFileInfo.hFileMapping);
			pDestObject->stFileInfo.hFileMapping = NULL;
		}

		if ( pDestObject->stFileInfo.hFile != NULL)
		{
			CloseHandle(pDestObject->stFileInfo.hFile);
			pDestObject->stFileInfo.hFile= NULL;
		}
	}
}


BOOL HashEngine::GetHashMd5(HANDLE hFile, DWORD dwFsize, BYTE *pMd5Str, DWORD dwBuffSize )
{
	BOOL	bRet = FALSE;
	BOOL	bReturn = FALSE;

	BYTE	*pStream = NULL;

	DWORD	dwByteofRead = 0;
	DWORD	dwHashBuffSize = 16;
	HCRYPTPROV	hProv = 0;
	HCRYPTPROV	hHash = 0;

	DWORD	dwIdx = 0;


	pStream =(BYTE*) malloc(dwFsize + 0x100);
	if (pStream == NULL)
		goto END;

	ZeroMemory(pStream, dwFsize+0x100);

	if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
		goto END;

	bRet = ReadFile(hFile, pStream, dwFsize, &dwByteofRead, NULL );
	if (bRet == 0 || dwByteofRead != dwFsize )
		goto END;

	bRet = CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
	if (bRet == FALSE)
		goto END;

	bRet = CryptCreateHash(hProv, CALG_MD5, NULL, NULL, &hHash);
	if (bRet == FALSE)
		goto END;

	bRet = CryptHashData(hHash, pStream, dwFsize, NULL);
	if (bRet == FALSE)
		goto END;

	dwHashBuffSize = dwBuffSize;

	bRet = CryptGetHashParam(hHash, HP_HASHVAL, pMd5Str, &dwHashBuffSize, NULL);
	if (bRet == FALSE)
		goto END;

	bReturn = TRUE;

END:
	if (pStream != NULL)
	{
		free(pStream);
		pStream = NULL;
	}
	if (hHash != NULL)
	{
		CryptDestroyHash(hHash);
		hHash = NULL;
	}
	if (hProv != NULL)
	{
		CryptReleaseContext(hProv, 0);
		hProv = NULL;
	}
	return bReturn;
}

BOOL HashEngine::ScanHashEng(PST_SCAN_INFO pDestObject)
{
	BOOL	bDetect = FALSE;
	BOOL	bFunReturn = FALSE;

	BYTE	pMD5Str[0x17] = {0,};


	INT		nIdx = 0;

	if(pDestObject == NULL || m_EnableEng == FALSE)
		goto COMM_END;

	bFunReturn = Openfile(pDestObject, ONLYREAD);
	if (bFunReturn == FALSE)
		goto COMM_END;

	for (nIdx = 0; nIdx < m_PatternSize; nIdx++)
	{
		if ( pDestObject->stFileInfo.dwFSize != g_stMD5Pattern[nIdx].dwSize )
			continue;

		bFunReturn = GetHashMd5(pDestObject->stFileInfo.hFile, pDestObject->stFileInfo.dwFSize, pMD5Str, sizeof(pMD5Str)-1);
		if (bFunReturn == FALSE)
			goto COMM_END;

		break;
	}

	if(bFunReturn == FALSE)
		goto COMM_END;


	for (nIdx = 0; nIdx < m_PatternSize; nIdx++)
	{
		if ( pDestObject->stFileInfo.dwFSize != g_stMD5Pattern[nIdx].dwSize )
			continue;

		if (memcmp(g_stMD5Pattern[nIdx].pHash, pMD5Str, 16) != 0)
			continue;

		bDetect = TRUE;
		_snwprintf(pDestObject->pwszInfectName, sizeof(pDestObject->pwszInfectName)-1, L"%s", g_stMD5Pattern[nIdx].pwszInfectName);
		pDestObject->pPrivateCureLogic = g_stMD5Pattern->pCureLogic;
		break;
	}


COMM_END:
	return bDetect;
}



BOOL HashEngine::IsCompareModuelePath(DWORD dwPid, WCHAR *wszTarget)
{
	BOOL		bRet = FALSE;

	MODULEENTRY32W	stModuleEntry = {0,};

	HANDLE			hSnap = NULL;

	if ( NULL == wszTarget )
	{
		goto Finish;
	}

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPid);
	if ( INVALID_HANDLE_VALUE == hSnap )
	{
		goto Finish;
	}

	stModuleEntry.dwSize = sizeof(MODULEENTRY32W);

	if ( !Module32FirstW(hSnap, &stModuleEntry) )
	{
		goto Finish;
	}

	do 
	{
		if ( wcslen(stModuleEntry.szExePath) == wcslen(wszTarget) )
		{
			if(wcsnicmp(stModuleEntry.szExePath, wszTarget, wcslen(wszTarget)) == 0)
			{
				bRet = TRUE;
				break;
			}
		}

	} while (Module32NextW(hSnap, &stModuleEntry));


Finish:
	if( INVALID_HANDLE_VALUE != hSnap && NULL != hSnap)
	{
		CloseHandle(hSnap);
		hSnap = NULL;
	}

	return bRet;
}


BOOL HashEngine::CureProcess(WCHAR *wszTarget)
{
	BOOL	bRet = FALSE;

	DWORD	dwStatus = 0;

	HANDLE	hSnap = NULL;
	HANDLE	hProcess = NULL;

	PROCESSENTRY32W	stEntry = {0,};

	if (NULL == wszTarget)
	{
		return FALSE;
	}

	hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hSnap)
	{
		goto END;
	}

	stEntry.dwSize = sizeof(stEntry);

	if (!Process32FirstW(hSnap, &stEntry))
	{
		goto END;
	}


	do 
	{
		if(IsCompareModuelePath(stEntry.th32ProcessID, wszTarget) == TRUE)
		{
			hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, stEntry.th32ProcessID);
			if (hProcess != NULL)
			{
				if (GetExitCodeProcess(hProcess, &dwStatus))
				{
					if (dwStatus == STILL_ACTIVE)
					{
						TerminateProcess(hProcess, dwStatus);
						bRet = TRUE;
					}					
				}				

				CloseHandle(hProcess);
				hProcess = NULL;
			}
		}

	} while (Process32NextW(hSnap, &stEntry));

END:
	if (hSnap != INVALID_HANDLE_VALUE && hSnap != NULL)
	{
		CloseHandle(hSnap);
		hSnap = NULL;
	}
	return bRet;
}


BOOL HashEngine::CureProcessForPrepare(WCHAR *wszTarget)
{
	WCHAR wszShortName[MAX_PATH*2] = {0,};

	if (wszTarget == NULL)
	{
		return 0;
	}

	CureProcess(wszTarget);

	if (GetShortPathNameW(wszTarget, wszShortName, sizeof(wszShortName)-1) != 0)
	{
		CureProcess(wszShortName);
	}

	return TRUE;
}

DWORD HashEngine::CureHashEng(PST_SCAN_INFO pDestObject)
{
	WCHAR	wszNewName[MAX_PATH*2] = {0,};

	DWORD	dwCureType = FALSE;
	DWORD	dwAttrib = 0;

	if (pDestObject == NULL)
	{
		return CURE_FAILED;
	}

	CureProcessForPrepare(pDestObject->stFileInfo.pwszFileFullPath);	

	Sleep(1000);

	dwAttrib = GetFileAttributesW(pDestObject->stFileInfo.pwszFileFullPath);
	if (dwAttrib != INVALID_FILE_ATTRIBUTES && dwAttrib & FILE_ATTRIBUTE_HIDDEN)
	{
		dwAttrib = FILE_ATTRIBUTE_NORMAL;
		SetFileAttributesW(pDestObject->stFileInfo.pwszFileFullPath, dwAttrib);
	}

	if (DeleteFileW( pDestObject->stFileInfo.pwszFileFullPath ) != 0)
		dwCureType = DELETE_SUCCESS;
	else
	{
		_snwprintf(wszNewName, sizeof(wszNewName)-1, L"%s.backup", pDestObject->stFileInfo.pwszFileFullPath);
		MoveFileW(pDestObject->stFileInfo.pwszFileFullPath, wszNewName);
		MoveFileExW(wszNewName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
		dwCureType = DELETE_REBOOT;
	}

COMM_END:
	return dwCureType;
}